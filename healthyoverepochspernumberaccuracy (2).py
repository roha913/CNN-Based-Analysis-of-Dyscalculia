# -*- coding: utf-8 -*-
"""HealthyOverEpochsPerNumberAccuracy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xEelvd8H6luE4BNkH6NI6Aj4yYtdyZiq
"""

import numpy as np
import cv2
import random
import matplotlib.pyplot as plt
import math
from math import sqrt, ceil, floor
from random import randint, choice

def random_shift(image,dx,dy):
    del_x = choice([-1,1])
    del_y = choice([-1,1])
    if(del_y == -1):
        image = np.delete(image,[list(range(0, randint(0,dx)))], axis = 1)
    else:
        image = np.delete(image,[list(range(len(image) - randint(0,dx), len(image)))], axis = 1)
    if(del_x == -1):
        image = np.delete(image,[list(range(0, randint(0,dx)))], axis = 0)
    else:
        image = np.delete(image,[list(range(len(image) - randint(0,dx), len(image)))], axis = 0)
    return image
def generate_circles(image_size, num_circles,rad_a,rad_b):
    image = np.zeros((image_size, image_size), dtype=np.uint8)
    c = 0
    x_centers = []
    y_centers = []
    while(c < num_circles):
        center_x = randint(1,int(image_size/(2*rad_b)))*(2*rad_b) - rad_b
        center_y = randint(1,int(image_size/(2*rad_b)))*(2*rad_b) - rad_b
        radius = randint(rad_a,rad_b)
        if(not(center_x in x_centers) and not(center_y in y_centers)):
            c += 1
            x_centers.append(center_x)
            y_centers.append(center_y)
            image = cv2.circle(image, (center_x,center_y), radius, (255,0,0), 2)
    #image = random_shift(image,int(rad_a/2), int(rad_a/2))
    return image
def generate_squares(image_size, num_sq,side_a,side_b):
    image = np.zeros((image_size, image_size), dtype=np.uint8)
    c = 0
    x_topleft = []
    y_topleft = []
    while(c < num_sq):
        xtl = randint(1,int(image_size/(side_b) - side_b))*side_b
        ytl = randint(1,int(image_size/(side_b) - side_b))*side_b
        side = randint(side_a, side_b)
        if(not(xtl in x_topleft) and not(ytl in y_topleft)):
            c += 1
            x_topleft.append(xtl)
            y_topleft.append(ytl)
            p1 = (xtl, ytl)
            p2 = (xtl + side, ytl)
            p3 = (xtl + side, ytl + side)
            p4 = (xtl, ytl + side)


            cv2.line(image, p1, p2, (255, 0, 0), 2)
            cv2.line(image, p2, p3, (255, 0, 0), 2)
            cv2.line(image, p3, p4, (255, 0, 0), 2)
            cv2.line(image, p4, p1, (255, 0, 0), 2)
    #image = random_shift(image,int(rad_a/2), int(rad_a/2))
    return image

training_data = []
nums = []
for i in range(0,5000):
    radiant = randint(1,10)
    shape = choice(["circle","square"])
    if(shape == "circle"):
       image = generate_circles(260, radiant, 10, 11)
    if(shape == "square"):
       image = generate_squares(260, radiant, 10, 11)
    image = np.vstack(image).astype(np.float)
    training_data.append(image)
    nums.append(radiant - 1)
training_data = np.array(training_data)
nums = np.array(nums)

#plt.imshow(generate_squares(260, 10, 5, 10))

import torch
import torch.nn as nn
import torch.optim as optim
conv_network = nn.Sequential(nn.Conv2d(1,8,3,padding = "same"),
                             nn.LeakyReLU(),
                             nn.MaxPool2d(2),
                             nn.Conv2d(8,16,3, padding = "same"),
                             nn.LeakyReLU(),
                             nn.MaxPool2d(2),
                             nn.Flatten(1),
                             nn.Linear(16*65*65, 32),
                             nn.LeakyReLU(),
                             nn.Linear(32,10),
                             #nn.Sigmoid()
                             )
conv_network = conv_network.cuda()

theta = torch.tensor(np.stack(training_data), dtype = torch.float).unsqueeze(1)
#conv_network(theta)
nums = torch.tensor(np.array(nums))
theta = theta.cuda()
nums = nums.cuda()
#print(data)

#testing data generation
testing_data = []
testing_nums = []
for i in range(0,5000):
    radiant = randint(1,10)
    shape = choice(["circle","square"])
    if(shape == "circle"):
       image = generate_circles(260, radiant, 10, 11)
    if(shape == "square"):
       image = generate_squares(260, radiant, 10, 11)
    image = np.vstack(image).astype(np.float)
    testing_data.append(image)
    testing_nums.append(radiant - 1)
testing_data = torch.tensor(np.stack(np.array(testing_data)), dtype = torch.float).unsqueeze(1).cuda()
testing_nums = np.array(testing_nums)

learning_rate = 0.01
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(conv_network.parameters(), lr = learning_rate)

#training
from sklearn.metrics import confusion_matrix
from sklearn import metrics
import matplotlib.pyplot as plt

num_epochs = 32
batch_size = 128
accuracy_data = []
print("len(theta)%batch_size" + str(len(theta)%batch_size))
for epoch in range(num_epochs):
    print("Epoch " + str(epoch))
    apm_sum = np.zeros(10)
    c = 0
    for batch in range(0,len(theta),batch_size):
        #print("New Batch: ")
        c += 1
        outputs = conv_network(theta[batch:batch+batch_size])
        im = testing_data[batch:batch + batch_size]
        outputanators = conv_network(im)
        predictions = outputanators.argmax(-1)
        pred_list = np.array(predictions.tolist())
        true_list = testing_nums[batch:batch + batch_size]
        accuracy_by_num = []
        conf_mat = confusion_matrix(true_list, pred_list)
        if(epoch == num_epochs - 1):
          cm_display = metrics.ConfusionMatrixDisplay(confusion_matrix = conf_mat, display_labels = ['0','1','2','3','4','5','6', '7', '8', '9'])
          cm_display.plot()
          plt.show()
        #print(conf_mat)
        shouldAdd = True
        for i in range(10):
          if(conf_mat.size == 100):
            if(np.sum(conf_mat[i]) == 0):
              print(conf_mat)
              quit()
            try:
              accuracy_by_num.append(conf_mat[i][i]/np.sum(conf_mat[i]))
            except:
              shouldAdd = False
          else:
            shouldAdd = False
        if(shouldAdd):
          apm_sum += np.array(accuracy_by_num)

        #Actual Model Learning
        labs = nums[batch:batch+128]
        loss = criterion(outputs,labs)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        #----------
    accuracy_data.append(apm_sum/c)

accuracy_data = np.array(accuracy_data)
print(accuracy_data.tolist())

print(accuracy_data.shape)

x = np.arange(0,num_epochs, 1)
#y = range(100,200)
fig = plt.figure()
ax1 = fig.add_subplot(111)

print(np.copy(accuracy_data[:0]).shape)
ax1.plot(x, np.copy(accuracy_data[:,0]), c='b', label='0')
ax1.plot(x, np.copy(accuracy_data[:,1]), c='r', label='1')
ax1.plot(x, np.copy(accuracy_data[:,2]), c='g', label='2')
ax1.plot(x, np.copy(accuracy_data[:,3]), c='y', label='3')
ax1.plot(x, np.copy(accuracy_data[:,4]), c='0.8', label='4')
ax1.plot(x, np.copy(accuracy_data[:,5]), c='k', label='5')
ax1.plot(x, np.copy(accuracy_data[:,6]), c='m', label='6')
ax1.plot(x, np.copy(accuracy_data[:,7]), c='c', label='7')
ax1.plot(x, np.copy(accuracy_data[:,8]), c=(1,0.5,0), label='8')
ax1.plot(x, np.copy(accuracy_data[:,9]), c=(0,1,1), label='9')
plt.legend(loc='lower right')
plt.show()

import pickle
impaired_accuracy = pickle.load(impaired_accur)









